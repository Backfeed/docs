\documentclass{article}
\usepackage{amsmath}
\setlength{\parskip}{.5em}
\begin{document}
\title{Backfeed Protocol - The Objective Layer}
\author{..}
\date{}
\maketitle

\section{Introduction}

This paper is the first in a series of chapters describing the several layers of the Backfeed protocol. 

It describes the {\em object layer} of the Backfeed Protocol. It describes a `minimal layer` of requirements. All other Backfeed Protocols are extensions of the basic protocol.

The paper will first sketch the general context of reputation flow in the system. 
We will then formulate a number of precise requirements that describe how reputation should flow in a system. Finally, we define function that satisfies these requirements. 
A reference implementation of the Backfeed Protocol can be found on http://hahahlol/

\section{Problem Statement}

We consider a system where there is an organization of a group of agents that have {\em reputation} that represents their influence in the system, and {\em tokens} that represent the property of the organization.

These agents can either {\em make a contribution} to the organization, or {\em evaluate a previous contribution} to help determine the value (in tokens) of that contribution. 


[We leave out tokens for now, just focus on rep]

More formally, we consider a system where there is a group of agents, which we will just represent by the numbers $N = \{1, ... , n\}$ and a reputation distribution ${\bf r} = \{r_1, ... r_n\}$, where each $r_i$ is a real number.
 
Each agent can do an action: it can either contribute a contribution $c$, which we will represent as the action $(i, c)$, or agent $i$ can make an evaluation $e$ of a contribution $c$, proposing value $v$ out a predefined set of numeric values (written as $(i,c,v)$ or as $e_{i,c,v}$).


[We leave out the contribution actions for now, and just focus on the reputation flow as the result of actions]


An evaluation action will typically involve a redistribution of the reputation in the system, where the redistribution depends on the current reputation distribution ${\bf r}$ as well as on the history $h = e_0 .. e_m$  of the previous evaluations made by the other users.\footnote{jelle: so I am leaving out reputation distributions of the previous states, to keep stuff manageable. This in realiyt represents a ``hidden assumption'', namely that our evaluation functions are, to use Elad's terms, ``dynamic'' instead of ``static''. It's my {\em ansatz}, if you will, and to my logician's mind it is a methodological mistake :-)}

More formally, each action $(i, c, v)$ gives rise to a state transition

\begin{center}
{ $h, {\bf r} \xrightarrow{i,c,v} {\bf r'}$ }
\end{center}
Or, if you prefer,  a function that takes a history and a reputation distribution as an argument, and returns a new reputation distribution:
\begin{center}
$F_{i,c,v}(h, {\bf r}) == {\bf r'}$
\end{center}
With its arguments ``unwrapped'', this function looks like this:
\begin{center}
$F_{i,c,v}((e_1, .. , e_m), \{r_1, .. r,_n\})$
\end{center}
Or:
\begin{center}
$F_{i,c,v}(((i_1,c_1,v_1), .. , (i_m, c_m, v_m)), \{r_1, .. r,_n\})$
\end{center}
We will use these notations interchangeably in the following, depending on what is most convenient.

Our task is to find a definition for this function that satisfies a number of requirements, that we will define in the next section.


\section{Conditions on Reputation Flow}

\subsection{Time Independence}

{\bf time independence:} Reputation flow of the i’th voter doesn’t rely on when he voted. Or, generalized, the {\em order} of the previous evaluations does not matter for calculating the new 

\begin{center}
$F_{i,c,v}((e_1, ..., e_i, e_k, .. , e_m), {\bf r}) = F_{i,c,v}((e_1, ...., e_k, e_i, ... , e_m), {\bf r})$
 

\end{center}

\subsection{Contribution Independence}

The reputation flow of resulting from the evaluation of a contribution $c$ should be independent of any previous evaluation of contributions other than $c$.

For any history $h$, define $h | c$ to be just like $h$, but with all evaluations of contributions not equal to c removed. Contribution Indipendence then can be formulated as:

\begin{center}
$F_{i,c,v}(h, {\bf r}) = F_{i,c,v}(h|c, {\bf r}) $
\end{center}

\subsection{Split Insensivity}

Split insensitivy means that it does not, everything else remaining equal, it should not matter that the effect on the system of two voters voting as a block (that is, always subequently and with corresponding votes), the effect on their combined reputation is the same as the effect on the information of a single agent that has the same reputation as the two combined.

Formally, let $k$ be an agent in $N$ , $N[k/{i,j}]$ be like N, but with $k$ removed and two new agents $i$ and $j$ added.

Similarly, let ${\bf r}[k/{i,j}]$ be a reputation distribution on $N[k/{i,j}]$, and let $h[k/{i,j}]$ be just like the history $h$, but with each evaluation $(k, c, v)$ substituted with $(i, c, v) (j, c, v)$.\footnote{todo: the formulation needs some cleaning up}

Now, given all this preliminary notation, split insensitivity can be formulated is several ways:

{\bf strong split insensititivy}: the reputation flow after an evaluation is indipendent of splitting:
\begin{center}
if $r_k = r[k/{l,m}]_i +r[k/{l,m}]_i$, then $F(h, {\bf r})[k/{l, m}] = F(h[k/{i,j}], {\bf r}[k/{l,m}])$
\end{center}


{\bf weak split insensititivy}: the reputation flow after an evaluation is indipendent of splitting:
\begin{center}
if $r_k = r[k/{i,j}]_i +r[k/{i,j}]_i$, then $F(h, {\bf r})_k = F(h[k/{i,j}], {\bf r}[k/{i,j}])_i + F(h[k/{i,j}], {\bf r}[k/{i,j}])_j$
\end{center}


\subsection{The earlier the better}

``
If all votes the same, earlier voter’s reputation gain greater than later voter’s
''

This again needs some new notation. 

The {\em reputation gain of $j$ given $(i, c, v)$} is defined as:
\begin{center}
 $ \Delta_{i, c, v}(h, {\bf r})_j = r_j -  F_{i, c, v}(h, {\bf r})_j$
\end{center}



\subsection{some name}

``
In the case of equal votes two evaluators with the same reputation evaluating consecutively with the same value, the first should be better off than the second.
''

\begin{center}
$\Delta_{i, c, v}(h, {\bf r})_i \ge \Delta_{j, c, v}(h\cdot(i,c,v), F_{i,c,v}(h, {\bf r}))_j$
\end{center}

\subsection{Reward consensus voters}

This is the main Backfeed Condition:
``
Reputation should be awarded to an early evaluator in the case that a later evaluator voted the same as her.
''
\begin{center}
if $(j, c, v)$ is an evaluation in $h$, then:
$\Delta_{i, c, v}(h, {\bf r})_j > 0$
\end{center}

\subsection{..}


Those who vote should earn in confront of those who do not vote

Requires that evaluations will trigger a reputation payment from non-voters to already voted.

It should be possible for any evaluator to regain at least the reputation put at stake upon evaluating.

(optional) Reputation potential gain should be proportional to reputation put at stake
Requires the stake to be a decreasing function of the engaged reputation.
Evaluation load should be reasonable - the system can’t get stuck because contributions don’t reach consensus.

\subsection{Results}


{\bf lemma:}
Commutativity: if I first vote for contribution A and then for B should have the same effect as first voting for B and then for A.

(This follows from ``contribution independence'')


{\bf lemma:}
Commutativity (2): Actions on different contributions should be commutative also on different agents: if X evaluates A and then Y evaluations B, this should have the same effect as first voting Y B and then X A.

(This follows from ``contribution independence'')

\section{The Backfeed Protocol}

\section{Appendix: maths, proofs, difficult stuff}


\end{document}